//! GPU-parallel constraint solver using graph coloring.
//!
//! This module implements a constraint-based physics solver that runs entirely on the GPU.
//! It uses graph coloring to enable parallel constraint solving while avoiding data races.
//!
//! # Solver Variants
//!
//! The module supports two main solver algorithms:
//!
//! - `Soft-TGS` (the same approach as Rapier and other engines like Box2D). This operates by splitting the simulation
//!   timestep into smaller substeps in order to lower errors caused by nonlinearities (e.g. rotations). Each substep
//!   is solved with a single PGS iteration (with bias) followed by position update, followed by another PGS iteration
//!   (without bias).
//! - `Soft-Jacobi`: this is similar to `Soft-TGS` but using a pseudo-Jacobi solver instead of PGS. It is "Jacobi-like"
//!   because, instead of solving each constraint independently in parallel, each **body** is solved
//!   in parallel. This means that each thread will solve all the constraints affecting a given body
//!   independently. Note that this technically violates Newtonâ€™s third law. However, vanilla Jacobi
//!   proved to be entirely useless (too unstable) so we made this compromise.

use crate::dynamics::constraint::{GpuTwoBodyConstraint, GpuTwoBodyConstraintBuilder};
use crate::dynamics::prefix_sum::{PrefixSumWorkspace, WgPrefixSum};
use crate::dynamics::{GpuLocalMassProperties, GpuVelocity, GpuWorldMassProperties, WgConstraint};
use crate::dynamics::{GpuSimParams, WgBody, WgSimParams};
use wgcore::indirect::DispatchIndirectArgs;
use wgcore::kernel::KernelDispatch;
use wgcore::tensor::{GpuScalar, GpuVector};
use wgcore::Shader;
use wgebra::geometry::WgInv;
use wgparry::math::GpuSim;
use wgparry::queries::GpuIndexedContact;
use wgparry::{dim_shader_defs, substitute_aliases};
use wgpu::{ComputePass, ComputePipeline, Device};

/// GPU shader bundle for the constraint solver.
///
/// This shader contains all the compute pipelines needed for constraint-based physics solving,
/// including constraint initialization, sorting, solving, and integration.
#[derive(Shader)]
#[shader(
    derive(WgSimParams, WgBody, WgConstraint, WgInv),
    src = "solver.wgsl",
    src_fn = "substitute_aliases",
    shader_defs = "dim_shader_defs",
    composable = false
)]
pub struct WgSolver {
    /// Initializes constraints from contact manifolds.
    init_constraints: ComputePipeline,
    /// Sorts constraints by body pairs for cache coherency.
    sort_constraints: ComputePipeline,
    /// Updates nonlinear constraint terms during substeps.
    update_constraints: ComputePipeline,
    /// Clears solver velocities and constraint counts.
    cleanup: ComputePipeline,
    /// Applies warmstart impulses from previous frame.
    warmstart: ComputePipeline,
    /// Applies warmstart impulses from previous frame, without relying on graph coloring.
    warmstart_without_colors: ComputePipeline,
    /// Jacobi iteration step (parallel, lock-free).
    step_jacobi: ComputePipeline,
    /// Gauss-Seidel iteration step (sequential per color).
    step_gauss_seidel: ComputePipeline,
    /// Initializes solver velocity increments.
    init_solver_vels_inc: ComputePipeline,
    /// Applies accumulated solver velocity increments.
    apply_solver_vels_inc: ComputePipeline,
    /// Integrates positions from velocities.
    integrate: ComputePipeline,
    /// Writes solver velocities back to body storage.
    finalize: ComputePipeline,
    /// Removes CFM and bias terms for velocity-only solving.
    remove_cfm_and_bias: ComputePipeline,
    /// Resets the current color index to 0.
    reset_color: ComputePipeline,
    /// Increments the current color index.
    inc_color: ComputePipeline,
}

/// Arguments for constraint solver dispatch.
///
/// This structure bundles all the GPU buffers and parameters needed for running
/// the constraint solver. It's used by both the [`WgSolver::solve_tgs`] and
/// [`WgSolver::solve_pgs`] methods.
#[derive(Copy, Clone)]
pub struct SolverArgs<'a> {
    /// Total number of colliders in the simulation.
    pub num_colliders: u32,
    /// Contact manifolds generated by narrow-phase.
    pub contacts: &'a GpuVector<GpuIndexedContact>,
    /// Number of contacts.
    pub contacts_len: &'a GpuScalar<u32>,
    /// Indirect dispatch arguments based on contact count.
    pub contacts_len_indirect: &'a GpuScalar<DispatchIndirectArgs>,
    /// Solver constraints (output from constraint initialization).
    pub constraints: &'a GpuVector<GpuTwoBodyConstraint>,
    /// Builder data for initializing constraints.
    pub constraint_builders: &'a GpuVector<GpuTwoBodyConstraintBuilder>,
    /// Global simulation parameters.
    pub sim_params: &'a GpuScalar<GpuSimParams>,
    /// Number of colliders (as buffer).
    pub colliders_len: &'a GpuScalar<u32>,
    /// Indirect dispatch arguments for collider count.
    pub colliders_len_indirect: &'a GpuScalar<[u32; 3]>,
    /// Rigid body poses.
    pub poses: &'a GpuVector<GpuSim>,
    /// Rigid body velocities.
    pub vels: &'a GpuVector<GpuVelocity>,
    /// Solver working velocities.
    pub solver_vels: &'a GpuVector<GpuVelocity>,
    /// Solver output velocities.
    pub solver_vels_out: &'a GpuVector<GpuVelocity>,
    /// Accumulated velocity increments during substeps.
    pub solver_vels_inc: &'a GpuVector<GpuVelocity>,
    /// World-space mass properties.
    pub mprops: &'a GpuVector<GpuWorldMassProperties>,
    /// Local-space mass properties.
    pub local_mprops: &'a GpuVector<GpuLocalMassProperties>,
    /// Number of constraints per body.
    pub body_constraint_counts: &'a GpuVector<u32>,
    /// Constraint IDs associated with each body.
    pub body_constraint_ids: &'a GpuVector<u32>,
    /// Color assigned to each constraint by graph coloring.
    pub constraints_colors: &'a GpuVector<u32>,
    /// Current color being processed.
    pub curr_color: &'a GpuScalar<u32>,
    /// Prefix sum shader for building constraint ranges.
    pub prefix_sum: &'a WgPrefixSum,
    /// Total number of colors from graph coloring.
    pub num_colors: u32,
}

impl WgSolver {
    const WORKGROUP_SIZE: u32 = 64;

    /// Prepares constraints for solving.
    ///
    /// This method:
    /// 1. Clears solver velocities and constraint counts
    /// 2. Initializes constraints from contact manifolds
    /// 3. Performs prefix sum to build body-to-constraint mapping
    /// 4. Sorts constraints by body pairs
    ///
    /// # Parameters
    ///
    /// - `device`: The WebGPU device
    /// - `pass`: Active compute pass for dispatching kernels
    /// - `args`: Solver arguments containing all necessary buffers
    /// - `prefix_sum_workspace`: Workspace for the prefix sum algorithm
    ///
    /// # GPU Performance
    ///
    /// Uses indirect dispatches based on the number of contacts, allowing the GPU
    /// to handle variable workloads efficiently.
    pub fn prepare<'a>(
        &self,
        device: &Device,
        pass: &mut ComputePass,
        args: SolverArgs<'a>,
        prefix_sum_workspace: &'a mut PrefixSumWorkspace,
    ) {
        KernelDispatch::new(device, pass, &self.cleanup)
            .bind_at(
                0,
                [
                    (args.solver_vels.buffer(), 3),
                    (args.body_constraint_counts.buffer(), 5),
                ],
            )
            .bind_at(
                1,
                [
                    (args.vels.buffer(), 2),
                    (args.mprops.buffer(), 3),
                    (args.colliders_len.buffer(), 4),
                ],
            )
            .dispatch(args.num_colliders.div_ceil(Self::WORKGROUP_SIZE));

        // Init constraints.
        KernelDispatch::new(device, pass, &self.init_constraints)
            .bind_at(
                0,
                [
                    (args.contacts.buffer(), 0),
                    (args.contacts_len.buffer(), 1),
                    (args.constraints.buffer(), 2),
                    (args.body_constraint_counts.buffer(), 5),
                ],
            )
            .bind_at(
                1,
                [
                    (args.sim_params.buffer(), 0),
                    (args.poses.buffer(), 1),
                    (args.vels.buffer(), 2),
                    (args.mprops.buffer(), 3),
                    (args.constraint_builders.buffer(), 7),
                ],
            )
            .dispatch_indirect(args.contacts_len_indirect.buffer());

        args.prefix_sum.dispatch(
            device,
            pass,
            prefix_sum_workspace,
            args.body_constraint_counts,
        );

        KernelDispatch::new(device, pass, &self.sort_constraints)
            .bind_at(
                0,
                [
                    (args.contacts.buffer(), 0),
                    (args.contacts_len.buffer(), 1),
                    (args.body_constraint_counts.buffer(), 5),
                    (args.body_constraint_ids.buffer(), 6),
                ],
            )
            .bind_at(1, [(args.mprops.buffer(), 3)])
            .dispatch_indirect(args.contacts_len_indirect.buffer());
    }

    /// Solves constraints using the TGS (Total Gauss-Seidel) algorithm.
    ///
    /// TGS is a constraint solver that provides better stability and convergence
    /// than traditional PGS. It uses multiple substeps with intermediate position integration
    /// and separate phases for bias (penetration correction) and velocity solving.
    ///
    /// # Algorithm Steps (per substep)
    ///
    /// 1. Apply accumulated velocity increments.
    /// 2. Update nonlinear constraint terms based on new positions.
    /// 3. Warmstart: apply previous frame's impulses.
    /// 4. Solve with bias: correct penetrations.
    /// 5. Integrate positions.
    /// 6. Solve without bias: solve for velocities only.
    pub fn solve_tgs<'a>(
        &self,
        device: &Device,
        pass: &mut ComputePass,
        mut args: SolverArgs<'a>,
        use_jacobi: bool,
    ) {
        let num_substeps = 4; // TODO: make this configurable.

        /*
         * Init solver vel increments.
         */
        KernelDispatch::new(device, pass, &self.init_solver_vels_inc)
            .bind_at(0, [])
            .bind_at(
                1,
                [
                    (args.sim_params.buffer(), 0),
                    (args.mprops.buffer(), 3),
                    (args.colliders_len.buffer(), 4),
                    (args.solver_vels_inc.buffer(), 6),
                ],
            )
            .dispatch((args.vels.len() as u32).div_ceil(Self::WORKGROUP_SIZE));

        for _ in 0..num_substeps {
            /*
             * Apply solver velocities increments.
             */
            KernelDispatch::new(device, pass, &self.apply_solver_vels_inc)
                .bind_at(0, [(args.solver_vels.buffer(), 3)])
                .bind_at(
                    1,
                    [
                        (args.colliders_len.buffer(), 4),
                        (args.solver_vels_inc.buffer(), 6),
                    ],
                )
                .dispatch((args.vels.len() as u32).div_ceil(Self::WORKGROUP_SIZE));

            /*
             * Update nonlinear terms.
             */
            KernelDispatch::new(device, pass, &self.update_constraints)
                .bind_at(
                    0,
                    [
                        (args.contacts_len.buffer(), 1),
                        (args.constraints.buffer(), 2),
                    ],
                )
                .bind_at(
                    1,
                    [
                        (args.sim_params.buffer(), 0),
                        (args.poses.buffer(), 1),
                        (args.constraint_builders.buffer(), 7),
                    ],
                )
                .dispatch_indirect(args.contacts_len_indirect.buffer());

            /*
             * Warmstart.
             */
            if !use_jacobi {
                const WARMSTART_WITHOUT_COLORS: bool = false;

                if WARMSTART_WITHOUT_COLORS {
                    KernelDispatch::new(device, pass, &self.warmstart_without_colors)
                        .bind_at(
                            0,
                            [
                                (args.constraints.buffer(), 2),
                                (args.solver_vels.buffer(), 3),
                                (args.body_constraint_counts.buffer(), 5),
                                (args.body_constraint_ids.buffer(), 6),
                            ],
                        )
                        .bind_at(1, [(args.colliders_len.buffer(), 4)])
                        .dispatch(args.vels.len().div_ceil(Self::WORKGROUP_SIZE as u64) as u32);
                } else {
                    KernelDispatch::new(device, pass, &self.reset_color)
                        .bind_at(0, [(args.curr_color.buffer(), 8)])
                        .dispatch(1);
                    for _ in 0..args.num_colors {
                        KernelDispatch::new(device, pass, &self.warmstart)
                            .bind_at(
                                0,
                                [
                                    (args.contacts_len.buffer(), 1),
                                    (args.constraints.buffer(), 2),
                                    (args.solver_vels.buffer(), 3),
                                    (args.constraints_colors.buffer(), 7),
                                    (args.curr_color.buffer(), 8),
                                ],
                            )
                            .dispatch_indirect(args.contacts_len_indirect.buffer());
                        KernelDispatch::new(device, pass, &self.inc_color)
                            .bind_at(0, [(args.curr_color.buffer(), 8)])
                            .dispatch(1);
                    }
                }
            }

            /*
             * Solve with bias.
             */
            if !use_jacobi {
                KernelDispatch::new(device, pass, &self.reset_color)
                    .bind_at(0, [(args.curr_color.buffer(), 8)])
                    .dispatch(1);
                for _ in 0..args.num_colors {
                    KernelDispatch::new(device, pass, &self.step_gauss_seidel)
                        .bind_at(
                            0,
                            [
                                (args.contacts_len.buffer(), 1),
                                (args.constraints.buffer(), 2),
                                (args.solver_vels.buffer(), 3),
                                (args.constraints_colors.buffer(), 7),
                                (args.curr_color.buffer(), 8),
                            ],
                        )
                        .dispatch_indirect(args.contacts_len_indirect.buffer());
                    KernelDispatch::new(device, pass, &self.inc_color)
                        .bind_at(0, [(args.curr_color.buffer(), 8)])
                        .dispatch(1);
                }
            } else {
                KernelDispatch::new(device, pass, &self.step_jacobi)
                    .bind_at(
                        0,
                        [
                            (args.constraints.buffer(), 2),
                            (args.solver_vels.buffer(), 3),
                            (args.solver_vels_out.buffer(), 4),
                            (args.body_constraint_counts.buffer(), 5),
                            (args.body_constraint_ids.buffer(), 6),
                        ],
                    )
                    .bind_at(1, [(args.colliders_len.buffer(), 4)])
                    .dispatch(args.vels.len().div_ceil(Self::WORKGROUP_SIZE as u64) as u32);
                std::mem::swap(&mut args.solver_vels, &mut args.solver_vels_out);
            }

            /*
             * Integrate positions only.
             */
            KernelDispatch::new(device, pass, &self.integrate)
                .bind_at(0, [(args.solver_vels.buffer(), 3)])
                .bind_at(
                    1,
                    [
                        (args.sim_params.buffer(), 0),
                        (args.poses.buffer(), 1),
                        (args.mprops.buffer(), 3),
                        (args.colliders_len.buffer(), 4),
                        (args.local_mprops.buffer(), 5),
                    ],
                )
                .dispatch((args.vels.len() as u32).div_ceil(Self::WORKGROUP_SIZE));

            /*
             * Solve WITHOUT bias.
             */
            KernelDispatch::new(device, pass, &self.remove_cfm_and_bias)
                .bind_at(
                    0,
                    [
                        (args.contacts_len.buffer(), 1),
                        (args.constraints.buffer(), 2),
                    ],
                )
                .dispatch_indirect(args.contacts_len_indirect.buffer());

            if !use_jacobi {
                KernelDispatch::new(device, pass, &self.reset_color)
                    .bind_at(0, [(args.curr_color.buffer(), 8)])
                    .dispatch(1);
                for _ in 0..args.num_colors {
                    KernelDispatch::new(device, pass, &self.step_gauss_seidel)
                        .bind_at(
                            0,
                            [
                                (args.contacts_len.buffer(), 1),
                                (args.constraints.buffer(), 2),
                                (args.solver_vels.buffer(), 3),
                                (args.constraints_colors.buffer(), 7),
                                (args.curr_color.buffer(), 8),
                            ],
                        )
                        .dispatch_indirect(args.contacts_len_indirect.buffer());
                    KernelDispatch::new(device, pass, &self.inc_color)
                        .bind_at(0, [(args.curr_color.buffer(), 8)])
                        .dispatch(1);
                }
            } else {
                KernelDispatch::new(device, pass, &self.step_jacobi)
                    .bind_at(
                        0,
                        [
                            (args.constraints.buffer(), 2),
                            (args.solver_vels.buffer(), 3),
                            (args.solver_vels_out.buffer(), 4),
                            (args.body_constraint_counts.buffer(), 5),
                            (args.body_constraint_ids.buffer(), 6),
                        ],
                    )
                    .bind_at(1, [(args.colliders_len.buffer(), 4)])
                    .dispatch(args.vels.len().div_ceil(Self::WORKGROUP_SIZE as u64) as u32);
                std::mem::swap(&mut args.solver_vels, &mut args.solver_vels_out);
            }
        }

        /*
         * Writeback body velocities.
         */
        KernelDispatch::new(device, pass, &self.finalize)
            .bind_at(0, [(args.solver_vels.buffer(), 3)])
            .bind_at(
                1,
                [
                    (args.vels.buffer(), 2),
                    (args.mprops.buffer(), 3),
                    (args.colliders_len.buffer(), 4),
                ],
            )
            .dispatch((args.vels.len() as u32).div_ceil(Self::WORKGROUP_SIZE));
    }
}

wgcore::test_shader_compilation!(WgSolver, wgcore, wgparry::dim_shader_defs());
